# Dinic 法の解説

## はじめに

Dinic 法は最大流を求めるアルゴリズムのひとつです。
最大流問題については `maxflow-editorial.md` を参照してください。用語および記号は同じものを使用します。

Dinic 法は、ネットワーク $(G,u,s,t)$ を入力として以下を満たす $f$ をひとつ求めるアルゴリズムです。
- $s-t$ フロー $f$ であって流量 $|f|$ が最大となる

時間計算量は $\mathrm{O}(|V|^2|E|)$ です。特殊なグラフではより強い保証を与えられますが、これについては後述します。

## 参考資料

次の資料を大きく参考にしました。その行間を埋めるとともに、アルゴリズムのお気持ちを言語化することを意識しました。

https://misawa.github.io/others/flow/dinic_time_complexity.html

## Dinic 法の概要

### アルゴリズム

1. 暫定解のフロー $f$ を $f=\boldsymbol{0}$ で初期化する ( $\forall e\in E, f(e)=0$ )。
2. 次の dual-primal step を $G_f$ の増加路が存在しなくなるまで繰り返す。
   
   dual-primal step

   dual step :
   - $G_f$ 上の $s-t$ 最短経路DAG $H_0$ を求める。
  
   primal step :
   - グラフ $H$ を $H_0$ で初期化する。
   - $H$ が空グラフになるまで次を繰り返す。
   - 1. $H$ 上の $s-t$ パスをひとつ求める。
   - 2. そのパス上にフローを流せるだけ流す。
   - 3. 容量が $0$ になった辺を $H$ から取り除く。
   - 4. $s$ から辿り着けない頂点、 $t$ へ辿り着けない頂点を $H$ から取り除く。
   - 5. 取り除いた頂点に隣接する辺を $H$ から取り除く。
   - 流れたフローを $f$ に反映する。
   - 特に $G_f$ の容量が更新される。
       
<details><summary>フローをベクトルとも見ることについて</summary>

フロー $f:E\to \mathbb{R}$ は写像ですが、扱うグラフは有限グラフなので $E$ の要素を適当に順序づけることができ、 $e_1,e_2,\dots ,e_{|E|}$ とすれば $\boldsymbol{f}=(f_1,f_2,\dots ,f_{|E|})$ であって $f_i=f(e_i)$ です。本文ではボールド表記をせず、 $f_i$ または $f(e)$ とかいたときに辺番号または辺を引数にとってその辺の流量を返すものします。

</details>

<details><summary>パスとは</summary>

パスは頂点列です。

$L$ を非負整数とします。長さ $L+1$ の列 $(v_0,v_1,\dots ,v_L)$ が
$G=(V,E)$ 上の $s-t$ パスであるとは、以下を満たすとき、またそのときに限ります。
- $v_0=s,\ v_{L+1}=t$
- $\forall i\in \lbrace 0,1,\dots, L-1 \rbrace , (v_i,v_{i+1})\in E$

特にそのパスの長さ (経路長) は $L$ です。

</details>

<details><summary>最短経路DAGとは</summary>

$s-t$ 最短経路DAG $H_0$ は $s-t$ 最短距離を $L$ として、 $s-t$ パスであって経路長が $L$ であるものを全て集めてできるグラフです。

</details>

<details><summary>フローを流せるだけ流すとは</summary>

$s-t$ パスを構成する辺の容量の最小値を $\delta$ として、 $s$ から $t$ へ流量 $\delta$ のフローを流します。つまり、暫定解のフロー $f$ に対して次を行います。
- $s-t$ パスを $(s=v_0,v_1,\dots ,v_L=t)$ とする。
- $\displaystyle\delta = \min_{i=0,1,\dots, L} u_f(v_i,v_{i+1})$ とする。
- $i= 0,1,\dots, L-1$ に対して $f(v_i,v_{i+1})\gets f(v_i,v_{i+1})+\delta$ という更新を行う。

</details>

## Dinic 法の時間計算量

### dual step の時間計算量

$1$ 回の dual-step に注目します。最短経路DAGを求める具体的な方法を確認すれば計算量解析は比較的容易に行えます。では見ていきましょう。 

- $G_f$ 上で $s$ を始点にして幅優先探索を行い、各頂点 $v$ について $s$ からの最短距離を記録する。
- これを $\mathrm{label}(v)$ とする。 $G_f$ において容量 $0$ の辺は削除されていることに注意する。
- $s$ から到達できない頂点 $v$ については $\mathrm{label}(v)=\infty$ とする。
- 次に $t$ を始点にして幅優先探索を行い、 $\mathrm{label}(u)+1=\mathrm{label}(v)$ となる辺 $(u,v)$ のみを逆に辿って ( $v\to u$ の向きに戻って) 到達できる頂点の集合 $V_0$ およびそのとき逆向きに通った辺の集合 $E_0$ を記録する。 
- $s-t$ 最短経路DAG $H_0$ は $H_0=(V_0,E_0)$ である。

実際のアルゴリズムは復元付き最短経路問題とほぼ同じです。幅優先探索の計算量解析は通る辺と頂点が何回探索されるかを見積もればよく、 $\mathrm{O}(|V|+|E|)$ です。

### primal step の時間計算量

$1$ 回の primal-step に注目します。次のパートの計算量解析が難しいです。

> - $H$ が空グラフになるまで次を繰り返す。
> - 1. $H$ 上の $s-t$ パスをひとつ求める。
> - 2. そのパス上にフローを流せるだけ流す。
> - 3. 容量が $0$ になった辺を $H$ から取り除く。
> - 4. $s$ から辿り着けない頂点、 $t$ へ辿り着けない頂点を $H$ から取り除く。
> - 5. 取り除いた頂点に隣接する辺を $H$ から取り除く。

#### 1 について

$s$ を始点として $s-t$ パスを構築します。このとき、いま扱っているグラフ $H$ は常に最短経路DAGを維持しているため、いま見ている頂点から出ている辺をひとつ **どれでもいい** ので選べば良いです。このため、計算量は $s-t$ パスの長さに比例することになりますが、これが高々 $H$ の頂点数なので、このパートの時間計算量は $\mathrm{O}(|V|)$ と評価できます。

<details><summary>通常の経路復元との違い</summary>

通常の経路復元は辺の数を $m$ として $\mathrm{O}(m)$ の時間計算量で行います。というのも、通常の経路復元では終点 $t$ からはじめ、今見ている頂点に向かっている辺を全て調べて適切な辺を選び、次の頂点に移動するということをします。すべての辺は高々 $1$ 度調べられ、最悪ケースではすべての辺が $1$ 度調べられることになります。従って、上述した計算量になります。

</details>

#### 2 について

1 の経路復元パートにおいて容量の最小値 $\delta$ も同時に管理すれば、パスに流すべきフローの流量は $\delta$ と分かります。パスの長さは高々 $|V|$ なので、このフローを $f$ に逐次反映すればこのパートの計算量は $\mathrm{O}(|V|)$ と評価できます。

#### 3 について

パスを構成する辺のうち、容量が 2 における $\delta$ に一致するものが少なくとも $1$ つあり、最大でもパスの長さだけそのような辺が存在します。よって削除する辺の数は $\mathrm{O}(|V|)$ と見積もることができますが、辺の削除がどのような計算量で行えるかはグラフの持ち方に依るところが大きいため、これについては後述します。なお、このパートは $1$ 回あたりの計算量の評価ではなく primal step 全体の計算量で評価するとより厳しいです。これも後述します。

<details><summary>グラフの持ち方と辺の削除について</summary>

グラフを多重辺のないグラフだとすれば、隣接行列で管理することで $\mathrm{O}(1)$ での辺の削除が可能です。しかしこの方法は通常用いられる隣接リストに比べて空間計算量を悪化させるため、本解説では扱いません。

さて、隣接リストで管理する場合は単純でないグラフにも対応可能ですが、辺の削除を $\mathrm{O}(1)$ で行うのは大変です。そこで、後述する改善されたアルゴリズムでは、この問題を間接的に解決します。

</details>

#### 4 について

このパートは、辺の削除によって $s$ から辿り着けなくなった頂点および $t$ へ辿り着けなくなった頂点の列挙を要求します。一見すれば、dual step と同様にもう一度 $s$ を始点とした幅優先探索を行う必要があるように思えます。このパートは文字通り頂点を列挙するのではまともな計算量解析を行うことができません(個人の感想です)。もし頂点列挙を頂点数に対して線形の時間計算量で行うことができれば、primal step 全体で見た計算量に良い評価を与えられますが、本解説ではこの説明はしません。代わりに、同等のアルゴリズムで陽にグラフの管理を行わない方法を後述します。

#### 5 について

4 と同様の事情でまともな計算量解析を行えないので。代わりのアルゴリズムを提案することで解決します。やっていることは変わらないので、アルゴリズム全体の流れをつかむ上では文字通りにすべて行われていると思っても構いません。

#### primal step 全体の計算量

primal step の中で行われる 1~5 の繰り返しは高々 $|E|$ 回しか行われません。なぜなら、3 で前述したように $H$ の辺は一度の繰り返しで少なくとも $1$ つは削除されるからです。よって、繰り返しの回数は $\mathrm{O}(|E|)$ と評価できます。

次に、3,4,5 で後回しにした計算量解析を行います。削除する辺および頂点の数に対して線形の時間計算量で削除できるという仮定のもとで、primal step 全体で見れば $\mathrm{O}(|E|+|V|)$ で行うことができます。

一度の繰り返しは $\mathrm{O}(|V|)$ の時間計算量で行うことができるため、primal step 全体で見れば $\mathrm{O}(|V||E|+|V|+|E|)=\mathrm{O}(|V||E|)$ の時間計算量で行うことができます。

### dual-primal step の計算量



[](
    /<details><summary></summary></details>
)