---
title: Mo on Tree
documentation_of: //tree/Mo_on_Tree.hpp
---

## 概要

木上の Mo's algorithm を扱います。

静的な列のいくつかの区間に対するクエリには Mo's algorithm が有効でした。これを静的な木のいくつかの単純パスに対するクエリに応用します。

このライブラリは、木上のクエリを列上のクエリに変換し、列上の Mo's algorithm と同様のインターフェースで扱えるようにしたものです。

しかし、このライブラリが扱える範囲は、列上の Mo's algorithm が扱えるものよりも狭いです。列上の Mo's algorithm は区間に含まれる値を集合より強く **列** として解釈したときの計算を行うことができます。一方、このライブラリが扱う木上の Mo's algorithm は、パスに含まれる値を一般には列としてではなく **集合** として解釈してもできる計算しか行うことができません。

例えば、次の問題 列A, 木A をみてください。

> 問題 列A 
>
> 逆元を持つ $d$ 次正方行列の列 $A=(A_1,A_2,\dots ,A_N)$ が与えられます。
> クエリが $Q$ 個与えられます。クエリでは列のある区間 $[l,r]$ が与えられるので、行列積 $A_l A_{l+1} \dots A_{r}$ を計算してください。
>
> 問題 木A
>
> $N$ 頂点の木が与えられます。各辺には逆元を持つ $d$ 次正方行列が定まっています。
> クエリが $Q$ 個与えられます。クエリでは木のある単純パス $u,v$ が与えられるので、 $u$ から $v$ に向かうときに通る辺に定まっている行列を順に掛け合わせていったものを計算してください。

列A は列上の Mo's algorithm で解くことができます。しかし、木A はこのライブラリの木上の Mo's algorithm では解くことができません。後述する工夫が必要です。

一方、次の問題　列B, 木B はどうでしょうか。

> 問題 列B
>
> 整数の列 $A=(A_1,A_2,\dots ,A_N)$ が与えられます。
> クエリが $Q$ 個与えられます。クエリでは列のある区間 $[l,r]$ が与えられるので、 $A_l A_{l+1} \dots A_{r}$ の種類数を計算してください。
>
> 問題 木A
>
> $N$ 頂点の木が与えられます。各辺には整数が定まっています。
> クエリが $Q$ 個与えられます。クエリでは木のある単純パス $u,v$ が与えられるので、 $u$ から $v$ に向かうときに通る辺に定まっている整数の種類数を計算してください。

列B はやはり列上の Mo's algorithm で解くことができます。また、木B はこのライブラリで解くことができます。

Aの問題は演算の順番が決まっていて、順番が異なれば計算結果(行列積)が異なり得るものでした。このため、木A はこのライブラリをそのまま用いることはできず、工夫が必要になります。
一方、Bの問題は演算の順番は決まっておらず、どの順番で計算しても計算結果(種類数)は異ならないのでした。このため木B はこのライブラリをそのまま用いて解くことができます。

---

木の **辺** に重みがある場合と木の **頂点** に重みがある場合で多少実装が異なるので、分けて説明します。

$N$ は扱う木の頂点数とします。木の頂点番号や添字は、特に断らない限り 0_indexed です。

## 辺に重みがある場合

変換には次の手順を行います。

1. 木のオイラーツアーを行い、訪れた **頂点** の列 $V=(v_0,v_1,\dots ,v_{2N-2})$ を作る。
2. 辺の列 $E=(e_0,e_1,\dots ,e_{2N-3})$ を $e_i=(v_i,v_{i+1})$ として定める。
3. $u,v$ パスに対するクエリは、 $V$ のすべての $u,v$ を含む極小な区間を $[l,r]$ として、 $E$ への区間クエリ $[l,r)$ として解釈する。
4. 変換した区間に同じ辺が $k$ 個含まれるとき、パスにはその辺は $k\bmod 2$ 個含まれることになる。

ここで、列上の Mo's algorithm では列の左右が区別できたのに対し、この変換ではパスの向きが失われていることに注意してください。このため、列上の Mo's algorithm が `add_left`, `add_right`, `del_left`, `del_right` を要求したのに対し、木上の Mo's algorithm は左右を区別せず `add`, `del` を要求します。そして、内部では区間に含まれる辺の集合を管理しながら、区間の伸縮に応じて `add` あるいは `del` を呼び出すようにしています。

`add` と `del` が逆元(元に戻す操作)の関係になっている場合は、演算が結合的であるならば、パスに含まれる辺は列として扱うことができます(交換則を満たす必要はありません)。ただし、パスの向きによって答えが変わる場合、このライブラリを素直に扱うことはできません。

しかし、演算の結合順序を逆向きにしたものを用意して $2$ 回アルゴリズムを実行し、どちらで正しい答えが得られるかを適切に判断すれば、解決できます。

演算の結合順序を逆向きにするとは、つまり列への追加 $A\ \overset{\mathrm{add}}\longleftarrow a$ を $A\circ a$ から $a\circ A$ に変更するということです。


### `MoTree_vertex<T>(int n)`

コンストラクタです。 $n$ 頂点の木を作る準備をします。辺の重みを保持する型を `T` とします。

### `void add_edge(int u, int v, T w)`

辺 $(u,v)$ を追加します。辺の重みは $w$ です。

### `void build(int q)`

$q$ クエリあるとし、前処理としてオイラーツアーを行います。

### `void insert(int u, int v)`

$u,v$ パスへのクエリを追加します。

### `void run(add, del, rem)`

辺の重み集合への $w$ の追加および削除を行うラムダ式 `add(T w)`, `del(T w)` と、 $i$ 番目に追加したクエリの答えを記録するラムダ式 `rem(int i)` を引数に取り、すべてのクエリを処理します。長さ $2N-2$ の列に対する Mo's algorithm の計算量になっていることに注意してください。

---

## 頂点に重みがある場合

頂点に重みがある場合は少し複雑になります。基本的なアイデアは、辺に重みがある場合に帰着することです。

まず、適当に根をとって木を根付き木にします。そして、根以外の頂点 $v$ に対しては、重みを $v$ の親との間の辺にあるものとします。

そして、パス $(u,v)$ に対するクエリは、 $u,v$ の LCA となる頂点の重みを先ほど帰着した辺に重みがある場合のパスクエリに加えたものとします。

辺に重みがある場合と比べて、重みの集合への追加削除を行う順番がパスに含まれる頂点の順になっていないことに注意してください。

パスに現れる順番で重みを考えたい場合は、辺に重みがある場合と同様の工夫により結合順序を両方用意し、さらにパスを LCA で分割してアルゴリズムを適用し、最後に結果を合わせることができれば良いことになります。結果を合わせることが必ずしも効率的にはできない可能性があります。(例えば、木Bの問題をこの方法で解くには、マージした集合の要素の種類数をマージ前の種類数のみから得る必要がありますが、これは一般には不可能です)


### `MoTree_edge<T>(int n, vector<T> b)`

コンストラクタです。 $n$ 頂点の木を作る準備をします。頂点の重みを保持する型を `T` とし、頂点 `i` の重みが `b[i]` であるような列を受け取ります。

### `void add_edge(int u, int v)`

辺 $(u,v)$ を追加します。

### `void build(int q)`

$q$ クエリあるとし、前処理としてオイラーツアーを行います。

### `void insert(int u, int v, int lca)`

$u,v$ パスへのクエリを追加します。ただし、木の根を頂点 $0$ としたときの頂点 $u,v$ の LCA を $lca$ とします。

### `void run(add, del, rem)`

頂点の重み集合への $w$ の追加および削除を行うラムダ式 `add(T w)`, `del(T w)` と、 $i$ 番目に追加したクエリの答えを記録するラムダ式 `rem(int i)` を引数に取り、すべてのクエリを処理します。長さ $2N-2$ の列に対する Mo's algorithm の計算量になっていることに注意してください。