---
title: 全部載せ木
documentation_of: //tree/heavy_light_decomposition.hpp
---

# `hld_tree`

根付き木に関する大抵のことが行えるライブラリを目指す。

頂点数を $n$ とすると、頂点番号は $0,1,\dots ,n-1$ で管理される。

空間計算量は全体で $\Theta(n)$ である。より正確には、（圧縮木の構築を行わない場合）合計で長さ $7n+\Theta(1)$ の `vector<int>` を使用する。

重軽分解を基本とした実装を行なっている。

グラフは隣接リストで保持されるが、二次元配列 `vector<vector<int>>` ではなく `noya2::internal::csr<int>` による一次元に圧縮した配列を利用している。

## (constructor)

```cpp
hld_tree (); // ... (1)
hld_tree (int n, int root = 0); // ... (2)
hld_tree (simple_tree g, int root = 0) // ... (3)
```

### 概要

`hld_tree` オブジェクトを次に示す通りの要素で初期化し、構築する。

### 効果

- (1) : デフォルトコンストラクタ。なにもしない。特に、意味のある木を構築しない。
- (2) : 頂点数が `n` の、`root` を根とする根付き木を、辺がない状態で構築する。辺は `add_edge` によって追加する。
- (3) : 木構造が `g` であり、`root` を根とする根付き木を構築する。

### 計算量

- (1) : $\Theta (1)$
- (2) : $\Theta (n)$
- (3) : $\Theta (n)$ (ここで $n$ は木構造 `g` の頂点数)

### 備考

- (1) はグローバルに `hld_tree` を置いておくときに使える。`main` 内部で初期化を行うが、グローバルに置いた関数で木の操作を行うときなど。

```cpp
hld_tree g;

int calc(int v){
    return g.depth(v);
}

int main(){
    int n; cin >> n; // 木 g の頂点数を入力
    g = hld_tree(n); // g を (2) の方法で初期化(代入)
    g.input(); // 木を入力
    cout << calc(n-1) << endl; // 頂点 n-1 の深さを出力
}
```

- (1) の方法で初期化されたオブジェクトに対して、どのメンバ関数も呼び出してはならない。宣言後に (2),(3) によって構築されたオブジェクトの代入が行われることを想定している。

- (3) は木構造 `simple_tree` を得ている場合にそのまま `hld_tree` にするためのコンストラクタである。`hld_tree::compressed_tree` は `simple_tree` を継承しているが、`hld_tree` の機能を持っていない。そのような場合に `add_edge` を経由せずに簡単に `hld_tree` を構築するための機能である。

## add_edge

```cpp
void add_edge(int u, int v);
```

### 概要

頂点 `u`, `v` を結ぶ（無向）辺を追加する。

### 要件

- $0\le u, v\lt n$
- コンストラクタ (2) で構築した場合、この関数はちょうど $n-1$ 回呼ばれる。
  - `input`, `input_parents` を読んだ場合は、内部で $n-1$ 回の `add_edge` が呼ばれる。
- $n-1$ 回呼ばれた後、グラフは木になっている。

### 計算量

償却定数時間。 $n-1$ 回の呼び出しに対して、内部での `build` の処理も含めて合計で $\Theta(n)$ 時間である。

### 備考

この関数が $n-1$ 回呼ばれたとき、内部で自動的に `build` が呼ばれる。それまでに辺の追加以外の関数を呼び出してはならない。
なお、`build` は `private` 指定されており、外部から直接呼び出すことはできない。

## input, input_parents

```cpp
void input(int indexed = 1); // ... (1)
void input_parents(int indexed = 1); // ... (2)
```

### 概要

辺の情報を標準入力から受け取って、辺を追加する。入力される頂点番号は `indexed, indexed+1, ..., indexed+n-1` のいずれかとする。

### 効果

- (1) : 木の構造が、 $i$ 番目の辺が頂点 $u_i,v_i$ を結ぶとして、以下の形式で与えられるとする。これらの入力を受け取って、辺をすべて `add_edge` に投げる。
> $u_1$ $v_1$
> 
> $u_2$ $v_2$
> 
> $\vdots$
>
> $u_{n-1}$ $v_{n-1}$

- (2) : 木の構造が、 根を `root` としたときの頂点 $i$ の親が頂点 $p_i$ として、以下の形式で与えられるとする。これらの入力を受け取って、辺の情報 $(i,p_i)$ に変換して、辺をすべて `add_edge` に投げる。
> $p_1$ $p_2$ $p_{n-1}$

### 計算量

- (1),(2) : $\Theta (n)$

### 備考

入力は `std::cin >>` によって受け取られる。入力を別の方法で行いたい場合は、入力と辺の追加は切り離し、辺の追加を `add_edge` で行うことができる。

木構造の指定方法は以下の $4$ つに限られる。

- コンストラクタ (3) による構築
- `add_edge` を $n-1$ 回呼ぶ
- `input` を $1$ 回呼ぶ
- `input_parents` を $1$ 回呼ぶ

どの方法でも木構造を指定できるが、複数の方法で行うことはできない。

